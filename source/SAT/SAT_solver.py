from pysat.formula import CNF
from pysat.solvers import Minisat22, Glucose42
from z3 import *
import time
import concurrent.futures
from constraints_encoding import *


def circle_method_fixed_last(n):
    if n % 2 != 0:
        raise ValueError("Number of teams must be even")

    teams = list(range(n - 1))  # Every team except the fixed one
    fixed = n - 1  # Fixed team
    schedule = []

    for round_num in range(n - 1):
        round_partite = []
        # The fixed team (n-1) faces the first team in the rotated list
        round_partite.append((fixed, teams[0]))
        for i in range(1, n // 2):
            round_partite.append((teams[i], teams[-i]))
        schedule.append(round_partite)

        # Ruota le squadre (escludendo la squadra fissa)
        teams = [teams[-1]] + teams[:-1]

    return schedule



'''def create_solver(n: int, solver_args: dict[str,], constraints: dict[str, bool] =None):
    # Each pair plays exactly once
    for i in Teams:
        for j in Teams:
            if i < j:
                pair_games = []
                for w in Weeks:
                    for p in Periods:
                        pair_games.append(match[i, j, w, p])
                solver.add(exactly_one(pair_games, name=f"pair_{i}_{j}"))

    # Each team plays once per week
    for w in Weeks:
        for t in Teams:
            occ = [match[h, a, w, p] 
                for p in Periods 
                for opp in Teams if opp != t
                for h, a in [(t, opp), (opp, t)]
                if (h, a, w, p) in match]
            solver.add(exactly_one(occ, name=f"team_{t}_week_{w}"))

    # Each team appears in same period at most twice
    for t in Teams:
        for p in Periods:
            occ = [match[h, a, w, p] 
                for w in Weeks 
                for opp in Teams if opp != t
                for h, a in [(t, opp), (opp, t)]
                if (h, a, w, p) in match]
            solver.add(at_most_k(occ, 2, name=f"team_{t}_period_{p}"))

    # No team plays vs. itself
    for i in Teams:
        for w in Weeks:
            for p in Periods:
                # La squadra i non puÃ² giocare contro se stessa
                if (i, i, w, p) in match:
                    solver.add(Not(match[i, i, w, p]), name=f"no_self_play_{i}_{w}_{p}")
    return'''


def create_solver_with_circle_method(n: int, solver_args: dict[str,], constraints: dict[str, bool] =None):
    """
    Creates a Z3 solver instance for the STS problem.

    Configures a SAT solver with constraints for the STS problem, starting from 
        an initial schedule generated by the circle method.
    Supports symmetry breaking and implied constraints that can be enabled/disabled.

    Args:
        n: Number of teams (must be even)
        solver_args: Dictionary containing problem parameters:
        constraints: Dictionary of constraint flags:
                    
    Returns:
        z3.Solver: Configured Z3 solver instance with all constraints added
    """

    # Default constraints
    if constraints is None: 
        constraints = {
            'matches_per_team': True,
            'different_match_per_period': True,
            'n_fix_period': True,
    }
    
    # Extract implied constraints flags
    ic_matches_per_team = constraints.get('matches_per_team', True)
    ic_different_match_per_period = constraints.get('different_match_per_period', True)
    # Extract symmetry breaking flags
    n_fix_period = constraints.get('n_fix_period', True)
    
    solver = Solver()

    n_weeks = solver_args['n_weeks']
    n_periods = solver_args['n_periods']
    Teams = solver_args['Teams']
    Weeks = solver_args['Weeks']
    Periods = solver_args['Periods']
    match = solver_args['match']

    # INITIAL WEEK MAPPING FROM CIRCLE METHOD
    initial_schedule = circle_method_fixed_last(n)
    for w, week_matches in enumerate(initial_schedule):
        for i, j in week_matches:
            # Fix the match (i, j) to be played in week w, but allow any period
            week_matches_vars = [match[i][j][w][p] for p in Periods]
            solver.add(exactly_one(week_matches_vars, name=f"match_{i}_{j}_week_{w}"))

    #-------------------CORE CONSTRAINTS-----------------------

    ''' # EACH PAIR PLAYS EXACTLY ONCE
    for i in Teams:
        for j in Teams:
            if i < j:  # Consider only one direction (i, j) to avoid duplicates
                pair_matches = []
                for w in Weeks:
                    for p in Periods:
                        pair_matches.append(match[i][j][w][p])
                        pair_matches.append(match[j][i][w][p])
                solver.add(exactly_one(pair_matches, name=f"pair_{i}_{j}_global"))'''


    # EVERY TEAM PLAYS MAX TWICE PER PERIOD DURING THE WHOLE TOURNAMENT
    for t in Teams:
        for p in Periods:
            # Collect all matches where team t plays in period p across all weeks
            occ = []
            for w in Weeks:
                for opp in Teams:
                    if t != opp:
                        occ.append(match[t][opp][w][p])  # t plays at home
                        occ.append(match[opp][t][w][p])  # t plays away
            # Debug: Print the collected variables
            
            # Add the constraint that the total occurrences are at most 2
            solver.add(at_most_k(occ, 2, name=f"team_{t}_max_twice_period_{p}"))

    #-------------------IMPLIED CONSTRAINTS-----------------------
    
    if ic_matches_per_team:
        # TOTAL MATCHES PER TEAM = n-1
        print(f"NO")
        for t in Teams:
            # Sum of all matches where team t plays (home or away)
            total_matches = []
            for w in Weeks:
                for p in Periods:
                    for opp in Teams:
                        if t != opp:
                            total_matches.append(match[t][opp][w][p]) 
                            total_matches.append(match[opp][t][w][p])  
            # the summ must be exactly n-1
            solver.add(at_most_k(total_matches, n - 1, name=f"matches_per_team_{t}"))
    
    if ic_different_match_per_period:
        # EVERY PERIOD CONTAINS DIFFERENT MATCHES 
        print(f"NO")
        for w in Weeks:
            for p in Periods:
                matches_in_period = []
                for i in Teams:
                    for j in Teams:
                        if i != j:
                            matches_in_period.append(match[i][j][w][p])
                
                solver.add(at_most_one(matches_in_period, name=f"unique_matches_week_{w}_period_{p}"))
    

    #-------------------SYMMETRY BREACKING-----------------------

    if n_fix_period:
        # Fix specific periods for teams n_team and n_team - 1
        print(f"NO")
        for w in Weeks:
            # Calculate the target period and the next period
            p_target = w % n_periods
            p_next = (p_target + 1) % n_periods

            # team n must play in the target period
            team_n_target = []
            for opp in Teams:
                if opp != n - 1:  
                    team_n_target.append(match[n - 1][opp][w][p_target])  # n team at home
                    team_n_target.append(match[opp][n - 1][w][p_target])  # n team away
            solver.add(Or(team_n_target))

            # Team n-1 must play in the next period (if within bounds)
            if w < n_weeks - 1:
                team_n_minus_1_next = []
                for opp in Teams:
                    if opp != n - 2: 
                        team_n_minus_1_next.append(match[n - 2][opp][w][p_next])  # n-1 team at home
                        team_n_minus_1_next.append(match[opp][n - 2][w][p_next])  # n-1 team away
                solver.add(Or(team_n_minus_1_next))

    return solver


def solve_sts(n: int, constraints=None, c_m_flag: bool = True, timeout: int = 300):
    """
    Solve the STS problem using SAT encoding.
    -use_circle_method: use the circle method for initial scheduling
    Args:
        n: Number of teams (must be even)
        constraints: Dictionary of constraint flags, with keys:
            -ic_matches_per_team: use implied constraint to set number of matches per team
            -ic_different_match_per_period: use implied constraint to set different matches each period
            -n_fix_period: use symmetry breaking to fix specific periods for certain teams
        c_m_flag: Whether to use the circle method for initial scheduling
        timeout: Timeout in seconds
    
    Returns:
        dict: Solution dictionary with 'solution', 'time', and 'satisfiable' keys
    """

    n_weeks = n - 1
    n_periods = n // 2
    Teams = range(n)
    Weeks = range(n_weeks)
    Periods = range(n_periods)    

    # Boolean variable: match[i][j][w][p] == True iff team i plays at home against team j in week w and period p
    match = [[[[Bool(f"match_{i}_{j}_{w}_{p}") for p in Periods] for w in Weeks] for j in Teams] for i in Teams]

    solver_args = {
        "n_weeks": n_weeks,
        "n_periods": n_periods,
        "Teams": Teams,
        "Weeks": Weeks,
        "Periods": Periods,
        "match": match
    }
    if c_m_flag:
        s = create_solver_with_circle_method(n, solver_args, constraints)
    #else:
    #    s = create_solver(n, solver_args, constraints)

    s.set("timeout", timeout * 1000)

    # Solve
    start_time = time.time()
    result = s.check()
    solve_time = time.time() - start_time
    
    if result == sat:
        m = s.model()
        sol = []
        for p in Periods:
            period = []
            for w in Weeks:
                found = False
                for i in Teams:
                    for j in Teams:
                        if i != j and m.evaluate(match[i][j][w][p], model_completion=True):
                            period.append([i + 1, j + 1])
                            found = True
                            break
                    if found:
                        break

        sol.append(period)
        
        return {
            'solution': sol,
            'time': solve_time,
            'satisfiable': True
        }
    else:
        return {
            'solution': None,
            'time': solve_time,
            'satisfiable': False
        }


def parse_variable_mappings(dimacs_lines: list[str]) -> dict[str, int]:
    """
    Parse variable mappings from DIMACS format lines.

    Args:
        dimacs_lines: List of strings representing lines in DIMACS format.
    Returns:
        dict[str, int]: Mapping from Z3 variable (str) to DIMACS variable (int).
    """
    var_mappings = {}

    for line in dimacs_lines:
        # Consider only comment lines that describe match variables
        if line.startswith('c ') and 'match_' in line:
            parts = line.split()
            if len(parts) >= 3:
                var_num_dimacs = int(parts[1])
                var_name_z3 = parts[2]      # e.g. match_0_1_2_3
                var_mappings[var_name_z3] = var_num_dimacs

    return var_mappings


def solve_sts_dimacs(n: int, constraints: dict[str, bool] =None, c_m_flag: bool = True, solver="minisat", timeout: int = 300):
    """
    Solve the STS problem using SAT encoding with DIMACS format.
    
    Args:
        n: Number of teams (must be even)
        constraints: Dictionary of constraint flags, with keys:
            -ic_matches_per_team: use implied constraint to set number of matches per team
            -ic_different_match_per_period: use implied constraint to set different matches each period
            -n_fix_period: use symmetry breaking to fix specific periods for certain teams
        c_m_flag: Whether to use the circle method for initial scheduling
        solver: Solver used with dimacs implementation
        timeout: Timeout in seconds
    
    Returns:
        dict: Solution dictionary with 'solution', 'time', and 'satisfiable' keys
    """

    n_weeks = n - 1
    n_periods = n // 2
    Teams = range(n)
    Weeks = range(n_weeks)
    Periods = range(n_periods)    
    
    # Boolean variable: match[i][j][w][p] == True iff team i plays at home against team j in week w and period p
    match = [[[[Bool(f"match_{i}_{j}_{w}_{p}") for p in Periods] for w in Weeks] for j in Teams] for i in Teams]

    solver_args = {
        "n_weeks": n_weeks,
        "n_periods": n_periods,
        "Teams": Teams,
        "Weeks": Weeks,
        "Periods": Periods,
        "match": match
    }

    if c_m_flag:
        s = create_solver_with_circle_method(n, solver_args, constraints)
    #else:
    #    s = create_solver(n, solver_args, constraints)


    start_time = time.time()
    # Convert Z3 solver to goal
    goal = Goal()
    goal.add(s.assertions()) 

    tactic = Then(Tactic("simplify"), Tactic("tseitin-cnf")) # Built the tactic pipeline
    result_goals = tactic(goal)
    cnf_goal = result_goals[0] # Get the final CNF
    dimacs_string = cnf_goal.dimacs() # Get DIMACS string
    var_mappings = parse_variable_mappings(dimacs_string.splitlines())

    # Parse DIMACS into PySAT CNF object
    cnf = CNF(from_string=dimacs_string)

    # Select solver
    pysat_solver = None
    if solver == "minisat":
        pysat_solver = Minisat22
    elif solver == "glucose":
        pysat_solver = Glucose42
    else:
        raise ValueError(f"Unsupported solver: {solver}")


    # Solve with timeout for pysat solvers
    def pysat_solve_with_model():
        with pysat_solver(bootstrap_with=cnf.clauses) as sat_solver:
            satisfiable = sat_solver.solve()
            model = sat_solver.get_model() if satisfiable else None # True if SAT, False if UNSAT
        return satisfiable, model

    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(pysat_solve_with_model)
        try:
            satisfiable, model = future.result(timeout=timeout)
        except concurrent.futures.TimeoutError:
            solve_time = time.time() - start_time
            return {
                'solution': None,
                'time': solve_time,
                'satisfiable': False
            }
        
    solve_time = time.time() - start_time # Solve time

    if not satisfiable or model is None:
        return {
            'solution': None,
            'time': solve_time,
            'satisfiable': False
        }

    # Parse the model into variable assignments (True/False)
    model_values = {}
    for val in model:
        var_num = abs(val)
        model_values[var_num] = val > 0
   

    # Build the solution from model values
    sol = []
    for w in Weeks:
        week = []
        for p in Periods:
            found = False
            for i in Teams:
                for j in Teams:
                    if i != j:
                        var_name = f"match_{i}_{j}_{w}_{p}"
                        var_num = var_mappings.get(var_name)
                        if var_num is not None and model_values.get(var_num, False):
                            week.append([i + 1, j + 1])  # or [i, j] for 0-based
                            found = True
                            break
                if found:
                    break
        sol.append(week)

    return {
        'solution': sol,
        'time': solve_time,
        'satisfiable': True
    }



def main():
    # PARAMETRI
    n_teams = 6  
    timeout = 300  
    use_circle_method = True  

    # VINCOLI
    constraints = {
        'matches_per_team': False,
        'different_match_per_period': False,
        'n_fix_period': False
    }

    # CAMBIA SOLVER
    result = solve_sts_dimacs(n=n_teams, constraints=constraints, c_m_flag=use_circle_method, solver = "minisat", timeout=timeout)

    

    if result['satisfiable']:
        print(f"Soluzione trovata in {result['time']:.2f} secondi:")
        for week_idx, week in enumerate(result['solution'], 1):
            print(f"Settimana {week_idx}:")
            for period_idx, period in enumerate(week, 1):
                print(f"  Periodo {period_idx}: {period}")
    else:
        print(f"Nessuna soluzione trovata (tempo impiegato: {result['time']:.2f} secondi).")






if __name__ == "__main__":
    main()